<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Wars: Galactic Defender</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #000000 0%, #0a0a2e 50%, #000000 100%);
            user-select: none;
        }
        #gameCanvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
        }
        #scoreDisplay, #timerDisplay, #healthDisplay, #waveDisplay, #comboDisplay, #dpsDisplay, #fpsDisplay {
            position: absolute;
            left: 10px;
            font-size: 18px;
            color: #FFD700;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        #scoreDisplay {
            top: 10px;
            font-size: 24px;
        }
        #timerDisplay {
            top: 40px;
        }
        #healthDisplay {
            top: 70px;
        }
        #waveDisplay {
            top: 100px;
        }
        #comboDisplay {
            top: 130px;
        }
        #dpsDisplay {
            top: 160px;
        }
        #fpsDisplay {
            top: 190px;
            font-size: 14px;
            color: #888;
        }
        #miniMap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            border-radius: 5px;
        }
        #powerUpIndicators {
            position: absolute;
            bottom: 60px;
            left: 10px;
            font-size: 14px;
            color: #FFA500;
            font-family: 'Courier New', monospace;
        }
        .powerUpActive {
            margin: 5px 0;
            padding: 5px 10px;
            background-color: rgba(255, 165, 0, 0.3);
            border-radius: 3px;
            border-left: 3px solid #FFA500;
        }
        #cooldownIndicators {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        .cooldown {
            width: 60px;
            height: 60px;
            border: 3px solid #FFD700;
            border-radius: 50%;
            position: relative;
            background-color: rgba(0, 0, 0, 0.7);
        }
        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }
        .cooldown-ready {
            border-color: #00FF00;
            box-shadow: 0 0 10px #00FF00;
        }
        #healthBar {
            position: absolute;
            top: 95px;
            left: 10px;
            width: 200px;
            height: 15px;
            background-color: rgba(50, 50, 50, 0.8);
            border: 2px solid #FFD700;
            border-radius: 3px;
        }
        #healthBarFill {
            height: 100%;
            background: linear-gradient(90deg, #00FF00 0%, #FFFF00 50%, #FF0000 100%);
            border-radius: 2px;
            transition: width 0.3s;
        }
        #winScreen, #loseScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #FFD700;
            background-color: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            display: none;
            text-align: center;
            font-family: 'Courier New', monospace;
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        #statsDisplay {
            font-size: 18px;
            margin-top: 20px;
            text-align: left;
        }
        .stat-row {
            margin: 8px 0;
            color: #FFA500;
        }
        #restartButton, .menuButton {
            font-size: 20px;
            padding: 12px 24px;
            margin: 10px;
            cursor: pointer;
            background-color: #FFD700;
            color: #000000;
            border: none;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
            pointer-events: auto;
            transition: all 0.3s;
        }
        #restartButton:hover, .menuButton:hover {
            background-color: #FFA500;
            transform: scale(1.1);
        }
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: #FFD700;
            background-color: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            display: none;
            text-align: center;
            font-family: 'Courier New', monospace;
            border: 3px solid #FFD700;
            pointer-events: auto;
        }
        #upgradeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            background-color: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            display: none;
            font-family: 'Courier New', monospace;
            border: 3px solid #FFD700;
            pointer-events: auto;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .upgrade-item {
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(255, 165, 0, 0.2);
            border-radius: 5px;
        }
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            background-color: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            display: block;
            text-align: center;
            font-family: 'Courier New', monospace;
            border: 3px solid #FFD700;
            pointer-events: auto;
        }
        #waveAnnouncement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            color: #FFD700;
            font-family: 'Courier New', monospace;
            display: none;
            text-shadow: 0 0 20px #FFD700;
            animation: pulse 0.5s ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        .difficulty-button {
            display: block;
            margin: 10px auto;
            width: 200px;
        }
        #finishFeature {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: #FFD700;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        .low-health-warning {
            box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.3);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        <div id="scoreDisplay">Score: 0</div>
        <div id="timerDisplay">Time: 00:00</div>
        <div id="healthDisplay">Health: 100%</div>
        <div id="healthBar">
            <div id="healthBarFill" style="width: 100%;"></div>
        </div>
        <div id="waveDisplay">Wave: 1</div>
        <div id="comboDisplay">Combo: x0</div>
        <div id="dpsDisplay">DPS: 0</div>
        <div id="fpsDisplay">FPS: 60</div>
        <canvas id="miniMap"></canvas>
        <div id="powerUpIndicators"></div>
        <div id="cooldownIndicators">
            <div class="cooldown cooldown-ready" id="shieldCooldown">
                <div class="cooldown-text">SPACE<br>Shield</div>
            </div>
            <div class="cooldown cooldown-ready" id="bombCooldown">
                <div class="cooldown-text">Q<br>Bomb</div>
            </div>
            <div class="cooldown cooldown-ready" id="dashCooldown">
                <div class="cooldown-text">E<br>Dash</div>
            </div>
        </div>
    </div>
    
    <div id="mainMenu">
        <h1 style="font-size: 48px; margin-bottom: 30px;">STAR WARS<br>Galactic Defender</h1>
        <button class="menuButton difficulty-button" onclick="startGame('easy')">Easy</button>
        <button class="menuButton difficulty-button" onclick="startGame('normal')">Normal</button>
        <button class="menuButton difficulty-button" onclick="startGame('hard')">Hard</button>
        <button class="menuButton difficulty-button" onclick="startGame('insane')">Insane</button>
        <hr style="margin: 20px 0; border-color: #FFD700;">
        <button class="menuButton" onclick="startGame('endless')">Endless Mode</button>
        <button class="menuButton" onclick="startGame('timeattack')">Time Attack (60s)</button>
        <button class="menuButton" onclick="startGame('survival')">Survival (1 Life)</button>
        <button class="menuButton" onclick="showUpgradeMenu()">Upgrades</button>
        <div style="margin-top: 20px; font-size: 14px; color: #FFA500;">
            High Score: <span id="highScoreDisplay">0</span>
        </div>
    </div>
    
    <div id="pauseMenu">
        <h2>PAUSED</h2>
        <button class="menuButton" onclick="togglePause()">Resume</button>
        <button class="menuButton" onclick="returnToMainMenu()">Main Menu</button>
    </div>
    
    <div id="upgradeMenu">
        <h2 style="text-align: center;">Upgrades</h2>
        <div style="text-align: center; margin-bottom: 20px;">
            Total Score: <span id="upgradeScore">0</span>
        </div>
        <div id="upgradeList"></div>
        <button class="menuButton" onclick="closeUpgradeMenu()">Close</button>
    </div>
    
    <div id="winScreen">
        <div style="font-size: 48px; margin-bottom: 20px;">Victory!</div>
        <div style="font-size: 24px; margin-bottom: 20px;">The Force is Strong with You!</div>
        <div id="statsDisplay"></div>
        <button id="restartButton">New Mission</button>
        <button class="menuButton" onclick="returnToMainMenu()">Main Menu</button>
    </div>
    
    <div id="loseScreen">
        <div style="font-size: 48px; margin-bottom: 20px;">Defeat</div>
        <div style="font-size: 24px; margin-bottom: 20px;">You've Turned to the Dark Side!</div>
        <div id="statsDisplay2"></div>
        <button id="restartButton">Try Again</button>
        <button class="menuButton" onclick="returnToMainMenu()">Main Menu</button>
    </div>
    
    <div id="waveAnnouncement"></div>
    
    <div id="finishFeature">
        Finish Line Appeared!
        <br>
        Reach 25 points to win!
    </div>

    <script>
        // ============================================
        // GAME INITIALIZATION AND DOM ELEMENTS
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const miniMapCanvas = document.getElementById('miniMap');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        miniMapCanvas.width = 150;
        miniMapCanvas.height = 150;

        // DOM Elements
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const healthDisplay = document.getElementById('healthDisplay');
        const healthBarFill = document.getElementById('healthBarFill');
        const waveDisplay = document.getElementById('waveDisplay');
        const comboDisplay = document.getElementById('comboDisplay');
        const dpsDisplay = document.getElementById('dpsDisplay');
        const fpsDisplay = document.getElementById('fpsDisplay');
        const winScreen = document.getElementById('winScreen');
        const loseScreen = document.getElementById('loseScreen');
        const pauseMenu = document.getElementById('pauseMenu');
        const mainMenu = document.getElementById('mainMenu');
        const upgradeMenu = document.getElementById('upgradeMenu');
        const waveAnnouncement = document.getElementById('waveAnnouncement');
        const powerUpIndicators = document.getElementById('powerUpIndicators');
        const restartButtons = document.querySelectorAll('#restartButton');

        // ============================================
        // SOUND EFFECTS (Placeholder comments)
        // ============================================
        // Different weapon sounds
        const shootSound = new Audio('https://example.com/laser-shot.mp3');
        const rapidFireSound = new Audio('https://example.com/rapid-fire.mp3');
        const laserBeamSound = new Audio('https://example.com/laser-beam.mp3');
        
        // Enemy type-specific destruction sounds
        const enemyDeathSound = new Audio('https://example.com/explosion-small.mp3');
        const strongEnemyDeathSound = new Audio('https://example.com/explosion-medium.mp3');
        const bossDeathSound = new Audio('https://example.com/explosion-large.mp3');
        
        // Boss music
        const bossMusicSound = new Audio('https://example.com/boss-music.mp3');
        
        // Power-up sounds
        const powerUpCollectSound = new Audio('https://example.com/power-up.mp3');
        const shieldActivateSound = new Audio('https://example.com/shield-up.mp3');
        const nukeSound = new Audio('https://example.com/nuke.mp3');
        
        // Background music
        const bgMusicSound = new Audio('https://example.com/background-music.mp3');
        
        // UI sounds
        const buttonClickSound = new Audio('https://example.com/button-click.mp3');
        const damageSound = new Audio('https://example.com/player-hit.mp3');

        // ============================================
        // GAME STATE VARIABLES
        // ============================================
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameover', 'victory'
        let difficulty = 'normal';
        let gameMode = 'normal';
        let score = 0;
        let wave = 1;
        let gameTime = 0;
        let enemies = [];
        let bullets = [];
        let powerUps = [];
        let particles = [];
        let stars = [];
        
        // Player stats
        let playerHealth = 100;
        let maxHealth = 100;
        const player = {
            x: 0,
            y: 0,
            width: 40,
            height: 40,
            color: '#00FF00',
            speed: 5,
            isDashing: false,
            dashTime: 0
        };

        // Combat stats
        let combo = 0;
        let maxCombo = 0;
        let lastHitTime = 0;
        let comboTimeout = 2; // seconds
        let totalDamage = 0;
        let dps = 0;
        let damageInLastSecond = [];
        
        // Statistics
        let stats = {
            enemiesDestroyed: 0,
            shotsFired: 0,
            shotsHit: 0,
            powerUpsCollected: 0,
            damageDealt: 0,
            timeSurvived: 0
        };

        // Shooting mechanics
        let lastShootTime = 0;
        let shotsPerSecond = 2;
        let bulletCount = 1;
        let bulletDamage = 1;

        // Enemy spawning
        let lastSpawnTime = 0;
        let enemiesPerSecond = 0.5;
        let lastEnemyIncrease = 0;
        let lastBossSpawn = 0;

        // Power-up system
        let lastPowerUpSpawn = 0;
        let activePowerUps = {
            shield: { active: false, endTime: 0 },
            rapidFire: { active: false, endTime: 0 },
            multiShot: { active: false, endTime: 0 },
            laser: { active: false, endTime: 0 },
            scoreMultiplier: { active: false, endTime: 0, multiplier: 2 }
        };

        // Special abilities cooldowns
        let abilities = {
            shield: { cooldown: 15, lastUsed: -15, duration: 5 },
            bomb: { cooldown: 20, lastUsed: -20 },
            dash: { cooldown: 3, lastUsed: -3, duration: 0.3 }
        };

        // Upgrades (persistent)
        let upgrades = {
            fireRate: 0,
            bulletCount: 0,
            moveSpeed: 0,
            maxHealth: 0
        };

        // FPS tracking
        let lastFrameTime = performance.now();
        let fps = 60;
        let frameCount = 0;
        let fpsTime = 0;

        // Screen shake
        let screenShake = 0;

        // Wave system
        let waveInProgress = false;
        let wavePauseTime = 0;
        let enemiesThisWave = 0;
        let enemiesKilledThisWave = 0;

        // Object pooling
        let bulletPool = [];
        let particlePool = [];
        const POOL_SIZE = 200;

        // Touch controls (for mobile)
        let touchStartX = 0;
        let touchStartY = 0;
        let joystickActive = false;

        // ============================================
        // ENEMY TYPES CONFIGURATION
        // ============================================
        const enemyTypes = {
            weak: {
                health: 1,
                speed: 1.5,
                radius: 12,
                color: '#FF6666',
                points: 1,
                movement: 'straight'
            },
            normal: {
                health: 3,
                speed: 2,
                radius: 15,
                color: '#FF0000',
                points: 3,
                movement: 'straight'
            },
            strong: {
                health: 5,
                speed: 1.5,
                radius: 20,
                color: '#CC0000',
                points: 5,
                movement: 'zigzag'
            },
            tracker: {
                health: 4,
                speed: 1.8,
                radius: 15,
                color: '#FF00FF',
                points: 7,
                movement: 'tracking'
            },
            boss: {
                health: 50,
                speed: 0.8,
                radius: 40,
                color: '#8B0000',
                points: 50,
                movement: 'circular',
                isBoss: true
            }
        };

        // ============================================
        // DIFFICULTY SETTINGS
        // ============================================
        const difficultySettings = {
            easy: { healthMult: 1.5, damageMult: 0.7, spawnMult: 0.7 },
            normal: { healthMult: 1, damageMult: 1, spawnMult: 1 },
            hard: { healthMult: 0.8, damageMult: 1.3, spawnMult: 1.3 },
            insane: { healthMult: 0.5, damageMult: 1.5, spawnMult: 1.5 }
        };

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function getFromPool(pool, createFunc) {
            if (pool.length > 0) {
                return pool.pop();
            }
            return createFunc();
        }

        function returnToPool(pool, obj) {
            if (pool.length < POOL_SIZE) {
                pool.push(obj);
            }
        }

        function playSound(sound) {
            // Sound effects are disabled by default (placeholder URLs)
            try {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            } catch(e) {}
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function loadGameData() {
            try {
                const saved = localStorage.getItem('galacticDefender');
                if (saved) {
                    const data = JSON.parse(saved);
                    upgrades = data.upgrades || upgrades;
                    document.getElementById('highScoreDisplay').textContent = data.highScore || 0;
                }
            } catch(e) {}
        }

        function saveGameData() {
            try {
                const currentHighScore = parseInt(document.getElementById('highScoreDisplay').textContent) || 0;
                const data = {
                    upgrades: upgrades,
                    highScore: Math.max(score, currentHighScore)
                };
                localStorage.setItem('galacticDefender', JSON.stringify(data));
                document.getElementById('highScoreDisplay').textContent = data.highScore;
            } catch(e) {}
        }

        // ============================================
        // GAME OBJECT CREATION
        // ============================================
        function createEnemy(type) {
            const template = enemyTypes[type];
            const diffMult = difficultySettings[difficulty].damageMult;
            
            return {
                x: Math.random() * canvas.width,
                y: -template.radius,
                radius: template.radius,
                color: template.color,
                health: Math.ceil(template.health * diffMult),
                maxHealth: Math.ceil(template.health * diffMult),
                speed: template.speed * (0.8 + wave * 0.1),
                points: template.points,
                type: type,
                movement: template.movement,
                isBoss: template.isBoss || false,
                phase: 0,
                moveTime: 0,
                angle: 0,
                targetX: Math.random() * canvas.width
            };
        }

        function createBullet(x, y, angle = 0) {
            const bullet = getFromPool(bulletPool, () => ({}));
            bullet.x = x;
            bullet.y = y;
            bullet.width = 5;
            bullet.height = 10;
            bullet.color = activePowerUps.laser.active ? '#FF00FF' : '#00FFFF';
            bullet.speed = 7;
            bullet.angle = angle;
            bullet.damage = bulletDamage;
            return bullet;
        }

        function createPowerUp() {
            const types = ['shield', 'rapidFire', 'multiShot', 'laser', 'nuke', 'scoreMultiplier'];
            const type = types[Math.floor(Math.random() * types.length)];
            const colors = {
                shield: '#00FFFF',
                rapidFire: '#FF00FF',
                multiShot: '#FFFF00',
                laser: '#FF0000',
                nuke: '#FFA500',
                scoreMultiplier: '#FFD700'
            };
            
            return {
                x: Math.random() * canvas.width,
                y: -20,
                size: 20,
                color: colors[type],
                speed: 2,
                type: type
            };
        }

        function createParticle(x, y, color) {
            const particle = getFromPool(particlePool, () => ({}));
            particle.x = x;
            particle.y = y;
            particle.vx = (Math.random() - 0.5) * 5;
            particle.vy = (Math.random() - 0.5) * 5;
            particle.life = 1;
            particle.decay = 0.02;
            particle.color = color;
            particle.size = Math.random() * 3 + 2;
            return particle;
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 0.5 + 0.1,
                    size: Math.random() * 2
                });
            }
        }

        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        function drawStars() {
            ctx.fillStyle = '#FFFFFF';
            stars.forEach(star => {
                ctx.globalAlpha = 0.5 + star.size * 0.25;
                ctx.fillRect(star.x, star.y, star.size, star.size);
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            ctx.globalAlpha = 1;
        }

        function drawPlayer() {
            // Engine glow
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            
            // Main ship
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(player.x - player.width / 2, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();

            // Shield effect
            if (activePowerUps.shield.active || abilities.shield.lastUsed > gameTime - abilities.shield.duration) {
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x, player.y + player.height / 2, player.width, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Dash effect
            if (player.isDashing) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(player.x - player.width, player.y - 10, player.width * 2, player.height + 20);
            }
        }

        function drawEnemy(enemy) {
            // Draw health bar for bosses
            if (enemy.isBoss) {
                const barWidth = enemy.radius * 2;
                const barHeight = 5;
                const healthPercent = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.radius - 15, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#00FF00' : healthPercent > 0.25 ? '#FFFF00' : '#FF0000';
                ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.radius - 15, barWidth * healthPercent, barHeight);
            }

            // Draw enemy
            ctx.save();
            if (enemy.isBoss) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = enemy.color;
            }
            
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw different shapes for different types
            if (enemy.type === 'tracker') {
                ctx.strokeStyle = '#FF00FF';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawBullet(bullet) {
            ctx.save();
            ctx.shadowBlur = 10;
            ctx.shadowColor = bullet.color;
            ctx.fillStyle = bullet.color;
            
            if (activePowerUps.laser.active) {
                ctx.fillRect(bullet.x - 2, bullet.y, 4, 20);
            } else {
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
            }
            
            ctx.restore();
        }

        function drawPowerUp(powerUp) {
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = powerUp.color;
            ctx.fillStyle = powerUp.color;
            
            // Rotating star shape
            ctx.translate(powerUp.x, powerUp.y);
            ctx.rotate(gameTime * 2);
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5;
                const radius = i % 2 === 0 ? powerUp.size : powerUp.size / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        function drawParticles() {
            particles.forEach((p, index) => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    returnToPool(particlePool, p);
                    particles.splice(index, 1);
                }
            });
            ctx.globalAlpha = 1;
        }

        function drawMiniMap() {
            miniMapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            
            // Draw player
            const scaleX = miniMapCanvas.width / canvas.width;
            const scaleY = miniMapCanvas.height / canvas.height;
            
            miniMapCtx.fillStyle = '#00FF00';
            miniMapCtx.fillRect(player.x * scaleX - 2, player.y * scaleY - 2, 4, 4);
            
            // Draw enemies
            enemies.forEach(enemy => {
                miniMapCtx.fillStyle = enemy.isBoss ? '#FF00FF' : '#FF0000';
                const size = enemy.isBoss ? 4 : 2;
                miniMapCtx.fillRect(enemy.x * scaleX - size/2, enemy.y * scaleY - size/2, size, size);
            });
        }

        // ============================================
        // GAME LOGIC - ENEMY MOVEMENT
        // ============================================
        function updateEnemyPosition(enemy) {
            enemy.moveTime += 1/60;
            
            switch(enemy.movement) {
                case 'straight':
                    enemy.y += enemy.speed;
                    break;
                    
                case 'zigzag':
                    enemy.y += enemy.speed;
                    enemy.x += Math.sin(enemy.moveTime * 3) * 2;
                    break;
                    
                case 'circular':
                    enemy.y += enemy.speed * 0.5;
                    enemy.angle += 0.02;
                    enemy.x += Math.cos(enemy.angle) * 3;
                    break;
                    
                case 'tracking':
                    enemy.y += enemy.speed * 0.8;
                    const dx = player.x - enemy.x;
                    enemy.x += Math.sign(dx) * Math.min(Math.abs(dx) * 0.02, 2);
                    break;
            }
            
            // Keep enemies on screen horizontally
            enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
        }

        // ============================================
        // GAME LOGIC - COMBAT
        // ============================================
        function shoot() {
            if (gameTime - lastShootTime < 1 / shotsPerSecond) return;
            
            stats.shotsFired++;
            lastShootTime = gameTime;
            
            const spreadCount = bulletCount + (activePowerUps.multiShot.active ? 2 : 0);
            
            for (let i = 0; i < spreadCount; i++) {
                const angle = (i - (spreadCount - 1) / 2) * 0.2;
                const bullet = createBullet(player.x, player.y, angle);
                bullets.push(bullet);
            }
            
            playSound(activePowerUps.rapidFire.active ? rapidFireSound : shootSound);
        }

        function updateBullets() {
            bullets.forEach((bullet, bulletIndex) => {
                bullet.y -= bullet.speed;
                bullet.x += Math.sin(bullet.angle) * bullet.speed * 0.5;
                
                // Trail effect
                if (Math.random() < 0.3) {
                    particles.push(createParticle(bullet.x, bullet.y + 5, bullet.color));
                }
                
                if (bullet.y < -50 || bullet.x < -50 || bullet.x > canvas.width + 50) {
                    returnToPool(bulletPool, bullet);
                    bullets.splice(bulletIndex, 1);
                    return;
                }
                
                drawBullet(bullet);
            });
        }

        function checkCollisions() {
            bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    const dist = distance(bullet.x, bullet.y, enemy.x, enemy.y);
                    
                    if (dist < enemy.radius) {
                        // Hit!
                        stats.shotsHit++;
                        const damage = bullet.damage;
                        enemy.health -= damage;
                        
                        totalDamage += damage;
                        stats.damageDealt += damage;
                        damageInLastSecond.push({ time: gameTime, damage: damage });
                        
                        // Combo system
                        if (gameTime - lastHitTime < comboTimeout) {
                            combo++;
                        } else {
                            combo = 1;
                        }
                        maxCombo = Math.max(maxCombo, combo);
                        lastHitTime = gameTime;
                        
                        // Particles
                        for (let i = 0; i < 5; i++) {
                            particles.push(createParticle(enemy.x, enemy.y, enemy.color));
                        }
                        
                        returnToPool(bulletPool, bullet);
                        bullets.splice(bulletIndex, 1);
                        
                        if (enemy.health <= 0) {
                            // Enemy destroyed
                            stats.enemiesDestroyed++;
                            enemiesKilledThisWave++;
                            
                            const scoreMultiplier = activePowerUps.scoreMultiplier.active ? 
                                activePowerUps.scoreMultiplier.multiplier : 1;
                            score += enemy.points * scoreMultiplier * Math.min(combo, 5);
                            
                            // Explosion particles
                            const particleCount = enemy.isBoss ? 30 : 10;
                            for (let i = 0; i < particleCount; i++) {
                                particles.push(createParticle(enemy.x, enemy.y, enemy.color));
                            }
                            
                            if (enemy.isBoss) {
                                screenShake = 20;
                                playSound(bossDeathSound);
                            } else {
                                screenShake = 5;
                                playSound(enemy.type === 'strong' ? strongEnemyDeathSound : enemyDeathSound);
                            }
                            
                            enemies.splice(enemyIndex, 1);
                        }
                    }
                });
            });
            
            // Player collision with enemies
            if (!activePowerUps.shield.active && 
                !(abilities.shield.lastUsed > gameTime - abilities.shield.duration) &&
                !player.isDashing) {
                enemies.forEach(enemy => {
                    const dist = distance(player.x, player.y + player.height/2, enemy.x, enemy.y);
                    if (dist < player.width/2 + enemy.radius) {
                        takeDamage(5);
                        screenShake = 10;
                    }
                });
            }
            
            // Power-up collection
            powerUps.forEach((powerUp, index) => {
                const dist = distance(player.x, player.y, powerUp.x, powerUp.y);
                if (dist < player.width/2 + powerUp.size) {
                    collectPowerUp(powerUp);
                    powerUps.splice(index, 1);
                }
            });
        }

        function takeDamage(amount) {
            const diffMult = difficultySettings[difficulty].damageMult;
            playerHealth -= amount * diffMult;
            updateHealthBar();
            playSound(damageSound);
            
            if (playerHealth <= 0) {
                endGame(false);
            }
        }

        function updateHealthBar() {
            const healthPercent = Math.max(0, playerHealth / maxHealth);
            healthBarFill.style.width = (healthPercent * 100) + '%';
            healthDisplay.textContent = `Health: ${Math.ceil(playerHealth)}%`;
            
            // Low health warning
            if (healthPercent < 0.25) {
                canvas.classList.add('low-health-warning');
            } else {
                canvas.classList.remove('low-health-warning');
            }
            
            // Clip gradient
            if (healthPercent > 0.66) {
                healthBarFill.style.background = '#00FF00';
            } else if (healthPercent > 0.33) {
                healthBarFill.style.background = '#FFFF00';
            } else {
                healthBarFill.style.background = '#FF0000';
            }
        }

        function collectPowerUp(powerUp) {
            stats.powerUpsCollected++;
            playSound(powerUpCollectSound);
            
            const duration = 10; // seconds
            
            switch(powerUp.type) {
                case 'shield':
                    activePowerUps.shield.active = true;
                    activePowerUps.shield.endTime = gameTime + duration;
                    break;
                case 'rapidFire':
                    activePowerUps.rapidFire.active = true;
                    activePowerUps.rapidFire.endTime = gameTime + duration;
                    shotsPerSecond *= 2;
                    break;
                case 'multiShot':
                    activePowerUps.multiShot.active = true;
                    activePowerUps.multiShot.endTime = gameTime + duration;
                    break;
                case 'laser':
                    activePowerUps.laser.active = true;
                    activePowerUps.laser.endTime = gameTime + duration;
                    bulletDamage = 3;
                    break;
                case 'nuke':
                    screenShake = 30;
                    playSound(nukeSound);
                    enemies.forEach(enemy => {
                        for (let i = 0; i < 15; i++) {
                            particles.push(createParticle(enemy.x, enemy.y, enemy.color));
                        }
                    });
                    score += enemies.reduce((sum, e) => sum + e.points, 0);
                    stats.enemiesDestroyed += enemies.length;
                    enemies = [];
                    break;
                case 'scoreMultiplier':
                    activePowerUps.scoreMultiplier.active = true;
                    activePowerUps.scoreMultiplier.endTime = gameTime + duration;
                    break;
            }
        }

        // ============================================
        // SPECIAL ABILITIES
        // ============================================
        function activateShield() {
            if (gameTime - abilities.shield.lastUsed < abilities.shield.cooldown) return;
            
            abilities.shield.lastUsed = gameTime;
            playSound(shieldActivateSound);
            
            // Create shield particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = player.x + Math.cos(angle) * player.width;
                const y = player.y + player.height/2 + Math.sin(angle) * player.width;
                particles.push(createParticle(x, y, '#00FFFF'));
            }
        }

        function activateBomb() {
            if (gameTime - abilities.bomb.lastUsed < abilities.bomb.cooldown) return;
            
            abilities.bomb.lastUsed = gameTime;
            screenShake = 25;
            playSound(nukeSound);
            
            // Destroy all enemies on screen
            enemies.forEach(enemy => {
                if (enemy.y > 0 && enemy.y < canvas.height) {
                    for (let i = 0; i < 10; i++) {
                        particles.push(createParticle(enemy.x, enemy.y, enemy.color));
                    }
                    score += Math.floor(enemy.points * 0.5); // Half points for bomb kills
                    stats.enemiesDestroyed++;
                }
            });
            enemies = enemies.filter(e => e.y < 0 || e.y > canvas.height);
        }

        function activateDash() {
            if (gameTime - abilities.dash.lastUsed < abilities.dash.cooldown) return;
            
            abilities.dash.lastUsed = gameTime;
            player.isDashing = true;
            player.dashTime = gameTime;
        }

        // ============================================
        // WAVE SYSTEM
        // ============================================
        function startWave() {
            waveInProgress = true;
            enemiesThisWave = 0;
            enemiesKilledThisWave = 0;
            
            // Announce wave
            waveAnnouncement.textContent = `Wave ${wave}`;
            waveAnnouncement.style.display = 'block';
            setTimeout(() => {
                waveAnnouncement.style.display = 'none';
            }, 2000);
            
            // Spawn boss every 3 waves
            if (wave % 3 === 0) {
                enemies.push(createEnemy('boss'));
                playSound(bossMusicSound);
            }
        }

        function updateWaveSystem() {
            if (!waveInProgress && gameTime - wavePauseTime > 3) {
                wave++;
                waveDisplay.textContent = `Wave: ${wave}`;
                startWave();
                
                // Increase difficulty
                enemiesPerSecond = 0.5 + wave * 0.1;
            }
        }

        // ============================================
        // SPAWNING LOGIC
        // ============================================
        function spawnEnemies() {
            if (gameTime - lastSpawnTime < 1 / (enemiesPerSecond * difficultySettings[difficulty].spawnMult)) {
                return;
            }
            
            lastSpawnTime = gameTime;
            
            // Determine enemy type based on wave
            let type = 'weak';
            const rand = Math.random();
            
            if (wave >= 10) {
                if (rand < 0.15) type = 'tracker';
                else if (rand < 0.35) type = 'strong';
                else if (rand < 0.65) type = 'normal';
                else type = 'weak';
            } else if (wave >= 5) {
                if (rand < 0.2) type = 'strong';
                else if (rand < 0.5) type = 'normal';
                else type = 'weak';
            } else if (wave >= 2) {
                if (rand < 0.6) type = 'normal';
                else type = 'weak';
            }
            
            enemies.push(createEnemy(type));
            enemiesThisWave++;
        }

        function spawnPowerUps() {
            if (gameTime - lastPowerUpSpawn < 12) return;
            
            lastPowerUpSpawn = gameTime;
            powerUps.push(createPowerUp());
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            timerDisplay.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            comboDisplay.textContent = `Combo: x${combo}`;
            
            // Calculate DPS
            damageInLastSecond = damageInLastSecond.filter(d => gameTime - d.time < 1);
            dps = damageInLastSecond.reduce((sum, d) => sum + d.damage, 0);
            dpsDisplay.textContent = `DPS: ${dps}`;
            
            // FPS
            fpsDisplay.textContent = `FPS: ${Math.round(fps)}`;
            
            // Power-up indicators
            let powerUpText = '';
            for (let [key, value] of Object.entries(activePowerUps)) {
                if (value.active) {
                    const timeLeft = Math.ceil(value.endTime - gameTime);
                    powerUpText += `<div class="powerUpActive">${key.toUpperCase()}: ${timeLeft}s</div>`;
                    
                    if (gameTime >= value.endTime) {
                        value.active = false;
                        // Reset effects
                        if (key === 'rapidFire') shotsPerSecond /= 2;
                        if (key === 'laser') bulletDamage = 1;
                    }
                }
            }
            powerUpIndicators.innerHTML = powerUpText;
            
            // Update cooldown displays
            updateCooldownDisplay('shieldCooldown', abilities.shield);
            updateCooldownDisplay('bombCooldown', abilities.bomb);
            updateCooldownDisplay('dashCooldown', abilities.dash);
        }

        function updateCooldownDisplay(elementId, ability) {
            const element = document.getElementById(elementId);
            const cooldownRemaining = ability.cooldown - (gameTime - ability.lastUsed);
            
            if (cooldownRemaining <= 0) {
                element.classList.add('cooldown-ready');
            } else {
                element.classList.remove('cooldown-ready');
                // Could add a visual indicator here for remaining time
            }
        }

        // ============================================
        // MAIN GAME LOOP
        // ============================================
        function updateGame() {
            if (gameState !== 'playing') {
                requestAnimationFrame(updateGame);
                return;
            }
            
            // FPS calculation
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            frameCount++;
            fpsTime += deltaTime;
            if (fpsTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }
            
            gameTime += 1/60;
            stats.timeSurvived = gameTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply screen shake
            if (screenShake > 0) {
                ctx.save();
                ctx.translate(
                    Math.random() * screenShake - screenShake / 2,
                    Math.random() * screenShake - screenShake / 2
                );
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }
            
            // Draw game objects
            drawStars();
            drawPlayer();
            
            // Update and draw enemies
            enemies.forEach((enemy, index) => {
                updateEnemyPosition(enemy);
                drawEnemy(enemy);
                
                if (enemy.y > canvas.height + enemy.radius) {
                    enemies.splice(index, 1);
                    if (!enemy.isBoss) {
                        score = Math.max(0, score - 1);
                    }
                }
            });
            
            // Update and draw bullets
            updateBullets();
            
            // Update and draw power-ups
            powerUps.forEach((powerUp, index) => {
                powerUp.y += powerUp.speed;
                drawPowerUp(powerUp);
                
                if (powerUp.y > canvas.height + powerUp.size) {
                    powerUps.splice(index, 1);
                }
            });
            
            // Draw particles
            drawParticles();
            
            if (screenShake > 0) {
                ctx.restore();
            }
            
            // Check collisions
            checkCollisions();
            
            // Spawn logic
            spawnEnemies();
            spawnPowerUps();
            
            // Wave system
            updateWaveSystem();
            
            // Update combo timeout
            if (gameTime - lastHitTime > comboTimeout) {
                combo = 0;
            }
            
            // Update dash
            if (player.isDashing && gameTime - player.dashTime > abilities.dash.duration) {
                player.isDashing = false;
            }
            
            // Update UI
            updateUI();
            drawMiniMap();
            
            // Check game mode conditions
            if (gameMode === 'timeattack' && gameTime >= 60) {
                endGame(true);
            }
            if (gameMode === 'survival' && playerHealth <= 0) {
                endGame(false);
            }
            
            requestAnimationFrame(updateGame);
        }

        // ============================================
        // GAME STATE MANAGEMENT
        // ============================================
        function startGame(mode) {
            // Parse mode
            if (['easy', 'normal', 'hard', 'insane'].includes(mode)) {
                difficulty = mode;
                gameMode = 'normal';
            } else {
                gameMode = mode;
            }
            
            // Apply upgrades
            maxHealth = 100 + upgrades.maxHealth * 20;
            playerHealth = maxHealth;
            shotsPerSecond = 2 + upgrades.fireRate * 0.5;
            bulletCount = 1 + upgrades.bulletCount;
            player.speed = 5 + upgrades.moveSpeed;
            
            // Reset game state
            gameState = 'playing';
            score = 0;
            wave = 1;
            gameTime = 0;
            enemies = [];
            bullets = [];
            powerUps = [];
            particles = [];
            combo = 0;
            maxCombo = 0;
            totalDamage = 0;
            lastSpawnTime = 0;
            lastPowerUpSpawn = 0;
            lastHitTime = 0;
            enemiesPerSecond = 0.5;
            bulletDamage = 1;
            waveInProgress = false;
            wavePauseTime = -5;
            
            stats = {
                enemiesDestroyed: 0,
                shotsFired: 0,
                shotsHit: 0,
                powerUpsCollected: 0,
                damageDealt: 0,
                timeSurvived: 0
            };
            
            activePowerUps = {
                shield: { active: false, endTime: 0 },
                rapidFire: { active: false, endTime: 0 },
                multiShot: { active: false, endTime: 0 },
                laser: { active: false, endTime: 0 },
                scoreMultiplier: { active: false, endTime: 0, multiplier: 2 }
            };
            
            abilities.shield.lastUsed = -abilities.shield.cooldown;
            abilities.bomb.lastUsed = -abilities.bomb.cooldown;
            abilities.dash.lastUsed = -abilities.dash.cooldown;
            
            // Position player
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            
            // Hide menus
            mainMenu.style.display = 'none';
            winScreen.style.display = 'none';
            loseScreen.style.display = 'none';
            pauseMenu.style.display = 'none';
            
            updateHealthBar();
            startWave();
        }

        function endGame(victory) {
            gameState = 'gameover';
            
            // Save high score
            saveGameData();
            
            // Display statistics
            const accuracy = stats.shotsFired > 0 ? (stats.shotsHit / stats.shotsFired * 100).toFixed(1) : 0;
            const statsHTML = `
                <div class="stat-row">Final Score: ${score}</div>
                <div class="stat-row">Enemies Destroyed: ${stats.enemiesDestroyed}</div>
                <div class="stat-row">Accuracy: ${accuracy}%</div>
                <div class="stat-row">Max Combo: x${maxCombo}</div>
                <div class="stat-row">Time Survived: ${Math.floor(stats.timeSurvived)}s</div>
                <div class="stat-row">Damage Dealt: ${stats.damageDealt}</div>
                <div class="stat-row">Power-ups Collected: ${stats.powerUpsCollected}</div>
            `;
            
            if (victory) {
                document.querySelector('#winScreen #statsDisplay').innerHTML = statsHTML;
                winScreen.style.display = 'block';
            } else {
                document.querySelector('#loseScreen #statsDisplay2').innerHTML = statsHTML;
                loseScreen.style.display = 'block';
            }
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseMenu.style.display = 'block';
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseMenu.style.display = 'none';
            }
        }

        function returnToMainMenu() {
            gameState = 'menu';
            mainMenu.style.display = 'block';
            winScreen.style.display = 'none';
            loseScreen.style.display = 'none';
            pauseMenu.style.display = 'none';
            upgradeMenu.style.display = 'none';
        }

        function showUpgradeMenu() {
            upgradeMenu.style.display = 'block';
            document.getElementById('upgradeScore').textContent = score;
            
            // Display upgrades
            const upgradeList = document.getElementById('upgradeList');
            upgradeList.innerHTML = `
                <div class="upgrade-item">
                    <strong>Fire Rate</strong> (Level ${upgrades.fireRate})<br>
                    Cost: ${(upgrades.fireRate + 1) * 10} points<br>
                    <button class="menuButton" onclick="purchaseUpgrade('fireRate')">Upgrade</button>
                </div>
                <div class="upgrade-item">
                    <strong>Bullet Count</strong> (Level ${upgrades.bulletCount})<br>
                    Cost: ${(upgrades.bulletCount + 1) * 15} points<br>
                    <button class="menuButton" onclick="purchaseUpgrade('bulletCount')">Upgrade</button>
                </div>
                <div class="upgrade-item">
                    <strong>Move Speed</strong> (Level ${upgrades.moveSpeed})<br>
                    Cost: ${(upgrades.moveSpeed + 1) * 10} points<br>
                    <button class="menuButton" onclick="purchaseUpgrade('moveSpeed')">Upgrade</button>
                </div>
                <div class="upgrade-item">
                    <strong>Max Health</strong> (Level ${upgrades.maxHealth})<br>
                    Cost: ${(upgrades.maxHealth + 1) * 20} points<br>
                    <button class="menuButton" onclick="purchaseUpgrade('maxHealth')">Upgrade</button>
                </div>
            `;
        }

        function closeUpgradeMenu() {
            upgradeMenu.style.display = 'none';
        }

        function purchaseUpgrade(type) {
            const costs = {
                fireRate: (upgrades.fireRate + 1) * 10,
                bulletCount: (upgrades.bulletCount + 1) * 15,
                moveSpeed: (upgrades.moveSpeed + 1) * 10,
                maxHealth: (upgrades.maxHealth + 1) * 20
            };
            
            const currentHighScore = parseInt(document.getElementById('highScoreDisplay').textContent) || 0;
            
            if (currentHighScore >= costs[type]) {
                upgrades[type]++;
                // Deduct from saved score (conceptually)
                saveGameData();
                showUpgradeMenu();
            } else {
                alert(`Not enough points! Need ${costs[type]}, have ${currentHighScore}`);
            }
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        // Mouse movement
        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'playing') return;
            
            player.x = e.clientX;
            player.y = e.clientY;
            
            // Clamp player position
            player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
            player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
        });

        // Mouse click to shoot
        canvas.addEventListener('click', () => {
            if (gameState === 'playing') {
                shoot();
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState === 'playing') {
                switch(e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        activateShield();
                        break;
                    case 'q':
                        activateBomb();
                        break;
                    case 'e':
                        activateDash();
                        break;
                    case 'escape':
                        togglePause();
                        break;
                }
            } else if (gameState === 'paused' && e.key === 'Escape') {
                togglePause();
            }
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                joystickActive = true;
                shoot();
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState === 'playing' && joystickActive) {
                const touch = e.touches[0];
                player.x = touch.clientX;
                player.y = touch.clientY;
                
                player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
                player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
        });

        // Restart buttons
        restartButtons.forEach(button => {
            button.addEventListener('click', () => {
                startGame(difficulty);
            });
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initStars();
        });

        // ============================================
        // INITIALIZATION
        // ============================================
        initStars();
        loadGameData();
        updateGame();
    </script>
</body>
</html>
